# Your snippets
#
# Atom snippets allow you to enter a simple prefix in the editor and hit tab to
# expand the prefix into a larger code block with templated values.
#
# You can create a new snippet in this file by typing "snip" and then hitting
# tab.
#
# An example CoffeeScript snippet to expand log to console.log:
#
# '.source.coffee':
#   'Console log':
#     prefix: 'log'
#     body: 'console.log $1'
#
# Each scope (e.g. '.source.coffee' above) can only be declared once.
#
# This file uses CoffeeScript Object Notation (CSON).
# If you are unfamiliar with CSON, you can read more about it in the
# Atom Flight Manual:
# http://flight-manual.atom.io/using-atom/sections/basic-customization/#_cson


#------------------------------------------------------------------------------------------------------------------------------
#
#        d8888 888       888 888    d8P
#       d88888 888   o   888 888   d8P
#      d88P888 888  d8b  888 888  d8P
#     d88P 888 888 d888b 888 888d88K
#    d88P  888 888d88888b888 8888888b
#   d88P   888 88888P Y88888 888  Y88b
#  d8888888888 8888P   Y8888 888   Y88b
# d88P     888 888P     Y888 888    Y88b
#
#------------------------------------------------------------------------------------------------------------------------------


'.awk.source':


  'for-each':
    prefix: 'for (i in array)'
    body: 'for (${1:i} in ${2:array}) {
    \t${3:# do something with array[i]}
    }'

  'function ()':
    prefix: 'function'
    body: 'function ${1:name}(${2:parameter-list}) {
    \t${3:# function-body}
    return
    }'

  'if-else':
    prefix: 'if'
    body: 'if (${1:condition}) {
    \t${2:# do something}
    }
    else {
    \t${3:# do something else}
    }'


#------------------------------------------------------------------------------------------------------------------------------
#
# 888888b.         d8888  .d8888b.  888    888
# 888  "88b       d88888 d88P  Y88b 888    888
# 888  .88P      d88P888 Y88b.      888    888
# 8888888K.     d88P 888  "Y888b.   8888888888
# 888  "Y88b   d88P  888     "Y88b. 888    888
# 888    888  d88P   888       "888 888    888
# 888   d88P d8888888888 Y88b  d88P 888    888
# 8888888P" d88P     888  "Y8888P"  888    888
#
#------------------------------------------------------------------------------------------------------------------------------


'.source.shell':


  '#!/bin/sh':
    prefix: 'sh'
    body: '#!/bin/sh\n'

  '#!/bin/bash':
    prefix: 'bash'
    body: '#!/bin/bash\n'

  'function':
    prefix: 'function'
    body: """function ${1:name}(${2:parameter}) {
    \t${3:#statements}
    }"""

  'for … done':
    prefix: 'for'
    body: """for (( ${1:i} = ${2:0}; ${1:i} < ${3:x}; ${1:i}++ ));
    \tdo
    \t\t${0:#statements}
    \tdone"""

  'if … fi':
    prefix: 'if'
    body: """if ${2:[[ ${1:condition} ]]};
    then
    \t${0:#statements}
    fi"""

  'case … esac':
    prefix: 'case'
    body: """case ${1:word} in
    \t${2:pattern} ) ${3:actions}
    \t$0;;
    esac"""


#------------------------------------------------------------------------------------------------------------------------------
#
#  .d8888b.   .d88888b.  8888888888 8888888888 8888888888 .d8888b.   .d8888b.  8888888b.  8888888 8888888b. 88888888888
# d88P  Y88b d88P" "Y88b 888        888        888       d88P  Y88b d88P  Y88b 888   Y88b   888   888   Y88b    888
# 888    888 888     888 888        888        888       Y88b.      888    888 888    888   888   888    888    888
# 888        888     888 8888888    8888888    8888888    "Y888b.   888        888   d88P   888   888   d88P    888
# 888        888     888 888        888        888           "Y88b. 888        8888888P"    888   8888888P"     888
# 888    888 888     888 888        888        888             "888 888    888 888 T88b     888   888           888
# Y88b  d88P Y88b. .d88P 888        888        888       Y88b  d88P Y88b  d88P 888  T88b    888   888           888
#  "Y8888P"   "Y88888P"  888        888        8888888888 "Y8888P"   "Y8888P"  888   T88b 8888888 888           888
#
#------------------------------------------------------------------------------------------------------------------------------


'.source.coffee':


  'Atom Keymap':
    prefix: 'key'
    body: '\'${1:body}\':\n  \'${2:cmd}-${3:i}\': \'${4:namespace}:${5:event}\'$6'

  'Atom Snippet':
    prefix: 'snip'
    body: '\'${1:.source.js}\':\n  \'${2:Snippet Name}\':\n    prefix: \'${3:Snippet Trigger}\'\n    body: \'${4:Hello World!}\'$5'

  'Atom Snippet With No Selector':
    prefix: 'snipns'
    body: '\'${1:Snippet Name}\':\n  prefix: \'${2:Snippet Trigger}\'\n  body: \'${3:Hello World!}\'$4'

  'Array Comprehension':
    prefix: 'fora'
    body: 'for ${1:name} in ${2:array}\n  ${0:# body...}'

  'Function (bound)':
    prefix: 'bfun'
    body: '(${1:args}) =>\n  ${0:# body...}'

  'Class':
    prefix: 'cla'
    body: 'class ${1:ClassName}${2: extends ${3:Ancestor}}\n\n  ${4:constructor: (${5:args}) ->\n    ${6:# body...}}\n  $7'

  'Else if':
    prefix: 'elif'
    body: 'else if ${1:condition}\n  ${0:# body...}'

  'Function':
    prefix: 'fun'
    body: '(${1:args}) ->\n  ${0:# body...}\n\n'

  'If .. Else':
    prefix: 'ife'
    body: 'if ${1:condition}\n  ${2:# body...}\nelse\n  ${3:# body...}'

  'If':
    prefix: 'if'
    body: 'if ${1:condition}\n  ${0:# body...}'

  'Object comprehension':
    prefix: 'foro'
    body: 'for ${1:key}, ${2:value} of ${3:Object}\n  ${0:# body...}'

  'Range comprehension (exclusive)':
    prefix: 'forrex'
    body: 'for ${1:name} in [${2:start}...${3:finish}]${4: by ${5:step}}\n  ${0:# body...}'

  'Range comprehension (inclusive)':
    prefix: 'forr'
    body: 'for ${1:name} in [${2:start}..${3:finish}]${4: by ${5:step}}\n  ${0:# body...}'

  'Switch':
    prefix: 'swi'
    body: 'switch ${1:object}\n  when ${2:value}\n    ${0:# body...}'

  'Ternary If':
    prefix: 'ifte'
    body: 'if ${1:condition} then ${2:value} else ${3:other}'

  'Try .. Catch':
    prefix: 'try'
    body: 'try\n  $1\ncatch ${2:error}\n  $3'

  'Unless':
    prefix: 'unl'
    body: '${1:action} unless ${2:condition}'

  'Subheader':
    prefix: '/3'
    body: '# $1\n# -------------------------\n$0'

  'log':
    prefix: 'log'
    body: 'console.log $0'

  'warn':
    prefix: 'warn'
    body: 'console.warn $0'

  'error':
    prefix: 'error'
    body: 'console.error $0'

  'require':
    prefix: 'req'
    body: '${1:sys} $3= require \'${2:${1:sys}}\'$4'

  'Describe block':
    prefix: 'de',
    body: 'describe "${1:description}", ->\n  ${2:body}'

  'It block':
    prefix: 'i',
    body: 'it "$1", ->\n  $2'

  'Before each':
    prefix: 'be',
    body: 'beforeEach ->\n  $1'

  'After each':
    prefix: 'af',
    body: 'afterEach ->\n  $1'

  'Expectation':
    prefix: 'ex',
    body: 'expect($1).to$2'

  'Range array':
    prefix: 'ra',
    body: '[[$1, $2], [$3, $4]]'

  'Point array':
    prefix: 'pt',
    body: '[$1, $2]'

  'Key-value pair':
    prefix: 'kv',
    body: '${1:\'${2:key}\'}: ${3:value}'

  'Create Jasmine spy':
    prefix: 'spy',
    body: 'jasmine.createSpy(\'${1:description}\')$2'

'.string.quoted.double.coffee:not(.string .source), .string.quoted.double.heredoc.coffee:not(.string .source)':

  'Interpolated Code':
    prefix: '#'
    body: '#{$1}$2'


#------------------------------------------------------------------------------------------------------------------------------
#
#  .d8888b.   .d88888b.
# d88P  Y88b d88P" "Y88b
# 888    888 888     888
# 888        888     888
# 888  88888 888     888
# 888    888 888     888
# Y88b  d88P Y88b. .d88P
#  "Y8888P88  "Y88888P"
#
#------------------------------------------------------------------------------------------------------------------------------


'.source.go':


  'package clause':
    prefix: 'pkg'
    body: "package ${1:name}"

  'single import':
    prefix: 'im'
    body: 'import "${1:package}"'

  'multiple imports':
    prefix: 'ims'
    body: "import (\n\t\"${1:package}\"\n)"

  'single constant':
    prefix: 'co'
    body: "const ${1:name} = ${2:value}"

  'multiple constants':
    prefix: 'cos'
    body: "const (\n\t${1:name} = ${2:value}\n)"

  'type interface declaration':
    prefix: 'tyi'
    body: "type ${1:name} interface {\n\t$0\n}"

  'type struct declaration':
    prefix: 'tys'
    body: "type ${1:name} struct {\n\t$0\n}"

  'type function declaration':
    prefix: 'tyf'
    body: 'type ${1:name} func(${2:commonParam}) ${3:returnParam}'

  'main package':
    prefix: 'pkgm'
    body: "package main\n\nfunc main() {\n\t$0\n}"

  'function declaration':
    prefix: 'func'
    body: "func $1($2) $3 {\n\t$0\n}"

  'variable declaration':
    prefix: 'var'
    body: "var ${1:name} ${2:type}"

  'switch statement':
    prefix: 'switch'
    body: "switch ${1:expression} {\ncase ${2:condition}:\n\t$0\n}"

  'case clause':
    prefix: 'cs'
    body: "case ${1:condition}:$0"

  'for statement':
    prefix: 'for'
    body:  "for ${1:index} := ${0:0}; $1 < ${2:count}; $1${3:++} {\n\t$0\n}"

  'for range statement':
    prefix: 'forr'
    body: "for ${1:var} := range ${2:var} {\n\t$0\n}"

  'channel declaration':
    prefix: 'ch'
    body: "chan ${1:type}"

  'map declaration':
    prefix: 'map'
    body: "map[${1:type}]${2:type}"

  'empty interface':
    prefix: 'in'
    body: "interface{}"

  'if statement':
    prefix: 'if'
    body: "if ${1:condition} {\n\t$0\n}"

  'else branch':
    prefix: 'el'
    body: "else {\n\t$0\n}"

  'if else statement':
    prefix: 'ie'
    body: "if ${1:condition} {\n\t$2\n} else {\n\t$0\n}"

  'if err != nil':
    prefix: 'iferr'
    body: "if err != nil {\n\t${1:return}\n}"

  'fmt.Println':
    prefix: 'fp'
    body: "fmt.Println(\"$1\")"

  'fmt.Printf':
    prefix: 'ff'
    body: "fmt.Printf(\"$1\", ${2:var})"

  'log.Println':
    prefix: 'lp'
    body: "log.Println(\"$1\")"

  'log.Printf':
    prefix: 'lf'
    body: "log.Printf(\"$1\", ${2:var})"

  'log variable content':
    prefix: 'lv'
    body: "log.Printf(\"${1:var}: %#+v\\\\n\", ${1:var})"

  'make(...)':
    prefix: 'make'
    body: "make(${1:type}, ${2:0})"

  'new(...)':
    prefix: 'new'
    body: "new(${1:type})"

  'panic(...)':
    prefix: 'pn'
    body: "panic(\"$0\")"

  'http ResponseWriter *Request':
    prefix: 'wr'
    body: "${1:w} http.ResponseWriter, ${2:r} *http.Request"

  'http Context ResponseWriter *Request':
    prefix: 'cwr'
    body: "${1:c} context.Context, ${2:w} http.ResponseWriter, ${3:r} *http.Request"

  'http.HandleFunc':
    prefix: 'hf'
    body: "${1:http}.HandleFunc(\"${2:/}\", ${3:handler})"

  'http handler declaration':
    prefix: 'hand'
    body: "func $1(${2:w} http.ResponseWriter, ${3:r} *http.Request) {\n\t$0\n}"

  'http.Redirect':
    prefix: 'rd'
    body: "http.Redirect(${1:w}, ${2:r}, \"${3:/}\", ${4:http.StatusFound})"

  'http.Error':
    prefix: 'herr'
    body: "http.Error(${1:w}, ${2:err}.Error(), ${3:http.StatusInternalServerError})"

  'http.ListenAndServe':
    prefix: 'las'
    body: "http.ListenAndServe(\"${1::8080}\", ${2:nil})"

  'http.Serve':
    prefix: 'sv'
    body: "http.Serve(\"${1::8080}\", ${2:nil})"

  'goroutine anonymous function':
    prefix: 'go'
    body: 'go func($1) {\n\t$2\n}($0)'

  'goroutine function':
    prefix: 'gf'
    body: 'go ${1:func}($0)'

  'defer statement':
    prefix: 'df'
    body: "defer ${1:func}($0)"

  'test function':
    prefix: 'tf'
    body: "func Test$1(t *testing.T) {\n\t$0\n}"

  'go template':
    prefix: 'got'
    body: """
      package ${1:main}

      import (
          "${2:fmt}"
      )

      func ${1:main}() {
          $3
      }
    """


#------------------------------------------------------------------------------------------------------------------------------
#
#  888888        d8888 888     888     d8888  .d8888b.   .d8888b.  8888888b.  8888888 8888888b. 88888888888
#    "88b       d88888 888     888    d88888 d88P  Y88b d88P  Y88b 888   Y88b   888   888   Y88b    888
#     888      d88P888 888     888   d88P888 Y88b.      888    888 888    888   888   888    888    888
#     888     d88P 888 Y88b   d88P  d88P 888  "Y888b.   888        888   d88P   888   888   d88P    888
#     888    d88P  888  Y88b d88P  d88P  888     "Y88b. 888        8888888P"    888   8888888P"     888
#     888   d88P   888   Y88o88P  d88P   888       "888 888    888 888 T88b     888   888           888
#     88P  d8888888888    Y888P  d8888888888 Y88b  d88P Y88b  d88P 888  T88b    888   888           888
#     888 d88P     888     Y8P  d88P     888  "Y8888P"   "Y8888P"  888   T88b 8888888 888           888
#   .d88P
# .d88P"
# 888P"
#
#------------------------------------------------------------------------------------------------------------------------------


".source.js, .source.jsx, .source.ts, .source.js-semantic":


  "describe":
    prefix: "desc"
    body: """
      describe('${1:description}', function() {
      \t${0:// body...}
      });
      """

  "it asynchronous":
    prefix: "ita"
    body: """
    it('${1:description}', function(done) {
    \t${0:// body...}
    });
    """

  "it pending":
    prefix: "itp"
    body: """
    it('${1:description}');
    """

  "it synchronous":
    prefix: "its"
    body: """
    it('${1:description}', function() {
    \t${0:// body...}
    });
    """

  "console.dir":
    prefix: "cd"
    body: "console.dir(${1:obj});"

  "console.error":
    prefix: "ce"
    body: "console.error(${1:obj});"

  "console.info":
    prefix: "ci"
    body: "console.info(${1:obj});"

  "console.log":
    prefix: "cl"
    body: "console.log(${1:obj});"

  "console.warn":
    prefix: "cw"
    body: "console.warn(${1:obj});"

  "addEventListener":
    prefix: "ae"
    body: """
    ${1:document}.addEventListener('${2:event}', function(e) {
    \t${0:// body...}
    });
    """

  "getAttribute":
    prefix: "ga"
    body: """
    ${1:document}.getAttribute('${2:attr}');
    """

  "removeAttribute":
    prefix: "ra"
    body: """
    ${1:document}.removeAttribute('${2:attr}');
    """

  "setAttribute":
    prefix: "sa"
    body: """
    ${1:document}.setAttribute('${2:attr}', ${3:value});
    """

  "appendChild":
    prefix: "ac"
    body: """
    ${1:document}.appendChild(${2:elem});
    """

  "removeChild":
    prefix: "rc"
    body: """
    ${1:document}.removeChild(${2:elem});
    """

  "classList.add":
    prefix: "ca"
    body: """
    ${1:document}.classList.add('${2:class}');
    """

  "classList.remove":
    prefix: "cr"
    body: """
    ${1:document}.classList.remove('${2:class}');
    """

  "classList.toggle":
    prefix: "ct"
    body: """
    ${1:document}.classList.toggle('${2:class}');
    """

  "createDocumentFragment":
    prefix: "cdf"
    body: """
    ${1:document}.createDocumentFragment();
    """

  "createElement":
    prefix: "cel"
    body: """
    ${1:document}.createElement(${2:elem});
    """

  "getElementsByClassName":
    prefix: "gc"
    body: """
    ${1:document}.getElementsByClassName('${2:class}');
    """

  "getElementById":
    prefix: "gi"
    body: """
    ${1:document}.getElementById('${2:id}');
    """

  "getElementsByTagName":
    prefix: "gt"
    body: """
    ${1:document}.getElementsByTagName('${2:tag}');
    """

  "innerHTML":
    prefix: "ih"
    body: """
    ${1:document}.innerHTML = '${2:elem}';
    """

  "querySelector":
    prefix: "qs"
    body: """
    ${1:document}.querySelector('${2:selector}');
    """

  "querySelectorAll":
    prefix: "qsa"
    body: """
    ${1:document}.querySelectorAll('${2:selector}');
    """

  "textContent":
    prefix: "tc"
    body: """
    ${1:document}.textContent = '${2:content}';
    """

  "forEach":
    prefix: "fe"
    body: """
    ${1:myArray}.forEach(function(${2:elem}) {
    \t${0:// body...}
    });
    """

  "for in":
    prefix: "fi"
    body: """
    for (${1:prop} in ${2:obj}) {
    \tif (${2:obj}.hasOwnProperty(${1:prop})) {
    \t\t${0:// body...}
    \t}
    }
    """

  "anonymous function":
    prefix: "afn"
    body: """
    function(${1:arguments}) {
    \t${0:// body...}
    }
    """

  "function apply":
    prefix: "apply"
    body: """
    ${1:methodName}.apply(${2:context}, [${3:arguments}])
    """

  "function call":
    prefix: "call"
    body: """
    ${1:methodName}.call(${2:context}, ${3:arguments})
    """

  "immediately-invoked function expression":
    prefix: "iife"
    body: """
    (function(${1:window}, ${2:document}) {
    \t${0:// body...}
    })(${1:window}, ${2:document});
    """

  "function as a property of an object":
    prefix: "ofn"
    body: """
    ${1:functionName}: function(${2:arguments}) {
    \t${3:// body...}
    }
    """

  "prototype":
    prefix: "pr"
    body: """
    ${1:ClassName}.prototype.${2:methodName} = function(${3:arguments}) {
    \t${0:// body...}
    }
    """

  "function":
    prefix: "fn"
    body: """
    function ${1:methodName} (${2:arguments}) {
    \t${0:// body...}
    }
    """

  "JSON.parse":
    prefix: "jp"
    body: "JSON.parse(${1:obj});"

  "JSON.stringify":
    prefix: "js"
    body: "JSON.stringify(${1:obj});"

  "alert":
    prefix: "al"
    body: """
    alert('${1:msg}');
    """

  "confirm":
    prefix: "co"
    body: """
    confirm('${1:msg}');
    """

  "debugger":
    prefix: "de"
    body: """
    debugger;
    """

  "prompt":
    prefix: "pm"
    body: """
    prompt('${1:msg}');
    """

  "use strict":
    prefix: "us"
    body: """
    'use strict';
    """

  "assert.deepEqual":
    prefix: "asd"
    body: """
    assert.deepEqual(${1:actual}, ${2:expected});
    """

  "assert.equal":
    prefix: "ase"
    body: """
    assert.equal(${1:actual}, ${2:expected});
    """

  "assert.notEqual":
    prefix: "asn"
    body: """
    assert.notEqual(${1:actual}, ${2:expected});
    """

  "module.exports":
    prefix: "me"
    body: """
    module.exports = ${1:name};
    """

  "process.exit":
    prefix: "pe"
    body: """
    process.exit(${1:code});
    """

  "require":
    prefix: "re"
    body: """
    require('${1:module}');
    """

  "setInterval":
    prefix: "si"
    body: """
    setInterval(function() {
    \t${0:// body...}
    }, ${1:delay});
    """

  "setTimeout":
    prefix: "st"
    body: """
    setTimeout(function() {
    \t${0:// body...}
    }, ${1:delay});
    """

#------------------------------------------------------------------------------------------------------------------------------
#
#   888888 888     888 888      8888888        d8888
#     "88b 888     888 888        888         d88888
#      888 888     888 888        888        d88P888
#      888 888     888 888        888       d88P 888
#      888 888     888 888        888      d88P  888
#      888 888     888 888        888     d88P   888
#      88P Y88b. .d88P 888        888    d8888888888
#      888  "Y88888P"  88888888 8888888 d88P     888
#    .d88P
#  .d88P"
# 888P"
#
#------------------------------------------------------------------------------------------------------------------------------


".source.julia":


  "Module":
    prefix: 'module'
    body: """
    module ${1:name}
    ${2}
    end  # module ${1}
    """

  "Bang":
    prefix: '#!'
    body: """#! /usr/bin/env julia
    $1"""

  'Multi-line comment':
    prefix: '#='
    body: """#=
    $1
    =#"""

   "Using":
      prefix: 'using'
      body: """using ${1:module}
      $2"""

   "Include":
      prefix: 'include'
      body: """include("${1:file}")
      $2"""

   "Typed variable":
      prefix: 'tv'
      body: '${1:var}::${2:type}'

  "Documented function":
    prefix: "functiond"
    body: '''
"""
    ${1:name}(${2:args})

${3:documentation}
"""
function ${1:name}(${2:args})
\t${4:body}
end
    '''

  "function":
    prefix: "function"
    body: '''
function ${1:name}(${2:args})
\t${3:body}
end
    '''

  'Else if':
    prefix: 'elseif'
    body: """
elseif ${1:condition}
\t$2
    """

  'Else if2':
    prefix: 'elif'
    body: """
elseif ${1:condition}
\t$2
    """

  "for":
    prefix: "for"
    body: '''
for ${1:variable}
\t$2
end
    '''

  "for/in":
    prefix: "forin"
    body: '''
for ${1:variable} in ${2:iterator}
\t$3
end
    '''

  "return":
      prefix: 'return'
      body: 'return $1'

  "if":
    prefix: "if"
    body: '''
if ${1:condition}
\t${2:body}
end
    '''

  "if/else":
    prefix: "ife"
    body: '''
if ${1:condition}
\t${2:true_body}
else
\t${3:false_body}
end
    '''

  "macro":
    prefix: "macro"
    body: '''
macro ${1:name}(${2:args})
\t${3:body}
end
    '''

  "try/catch":
    prefix: "try"
    body: '''
try
\t${1:try_block}
catch $2
\t$3
end
    '''

  "try/finally":
    prefix: "tryf"
    body: '''
try
\t$1
finally
\t$2
end
    '''

  "try/catch/finally":
    prefix: "trycf"
    body: '''
try
\t${1:try_block}
catch $2
\t$3
finally
\t$4
end
    '''

  "struct":
    prefix: "struct"
    body: '''
struct ${1:name}
\t${2:fields}
end
    '''

  "mutable struct":
    prefix: "mutable"
    body: '''
mutable struct ${1:name}
\t${2:fields}
end
    '''

  "abstract type":
    prefix: "abstract"
    body: 'abstract type ${1:name} end'

  "primtitive type":
    prefix: "primitive"
    body: 'primitive type ${1:name} ${2:bits} end'

  "while":
    prefix: "while"
    body: '''
while ${1:condition}
\t${2:body}
end
    '''

  'begin block':
    prefix: 'begin'
    body: """
begin
\t$1
end
    """

  'let block':
    prefix: 'let'
    body: """
let
\t$1
end
    """

  'do block':
    prefix: 'do'
    body: """
do ${1:args}
\t$2
end
    """

  "Documented function with end function indicator":
    prefix: "functiond#"
    body: '''
"""
    ${1:name}(${2:args})

${3:documentation}
"""
function ${1:name}(${2:args})
\t${4:body}
end # function
    '''

  "function with end function indicator":
    prefix: "function#"
    body: '''
function ${1:name}(${2:args})
\t${3:body}
end # function
    '''

  "for with end for indicator":
    prefix: "for#"
    body: '''
for ${1:variable}
\t$2
end # for
    '''

  "for/in with end for indicator":
    prefix: "forin#"
    body: '''
for ${1:variable} in ${2:iterator}
\t$3
end # for
    '''

  "if with end if indicator":
    prefix: "if#"
    body: '''
if ${1:condition}
\t${2:body}
end # if
    '''

  "if/else with end if indicator":
    prefix: "ife#"
    body: '''
if ${1:condition}
\t${2:true_body}
else
\t${3:false_body}
end # if
    '''

  "macro with end macro indicator":
    prefix: "macro#"
    body: '''
macro ${1:name}(${2:args})
\t${3:body}
end # macro
    '''

  "try/catch with end try indicator":
    prefix: "try#"
    body: '''
try
\t${1:try_block}
catch $2
\t$3
end # try
    '''

  "try/finally with end try indicator":
    prefix: "tryf#"
    body: '''
try
\t$1
finally
\t$2
end # try
    '''

  "try/catch/finally with end try indicator":
    prefix: "trycf#"
    body: '''
try
\t${1:try_block}
catch $2
\t$3
finally
\t$4
end # try
    '''

  "struct with end struct indicator":
    prefix: "struct#"
    body: '''
struct ${1:name}
\t${2:fields}
end # struct
    '''

  "mutable struct with end mutable struct indicator":
    prefix: "mutable#"
    body: '''
mutable struct ${1:name}
\t${2:fields}
end # mutable struct
    '''

  "while with end while indicator":
    prefix: "while#"
    body: '''
while ${1:condition}
\t${2:body}
end # while
    '''

  'begin block with end begin indicator':
    prefix: 'begin#'
    body: """
begin
\t$1
end # begin
    """

  'let block with end let indicator':
    prefix: 'let#'
    body: """
let
\t$1
end # let
    """

  'do block with end do indicator':
    prefix: 'do#'
    body: """
do ${1:args}
\t$2
end # do
    """


#------------------------------------------------------------------------------------------------------------------------------
#
# 888    888        d8888  .d8888b.  888    d8P  8888888888 888      888
# 888    888       d88888 d88P  Y88b 888   d8P   888        888      888
# 888    888      d88P888 Y88b.      888  d8P    888        888      888
# 8888888888     d88P 888  "Y888b.   888d88K     8888888    888      888
# 888    888    d88P  888     "Y88b. 8888888b    888        888      888
# 888    888   d88P   888       "888 888  Y88b   888        888      888
# 888    888  d8888888888 Y88b  d88P 888   Y88b  888        888      888
# 888    888 d88P     888  "Y8888P"  888    Y88b 8888888888 88888888 88888888
#
#------------------------------------------------------------------------------------------------------------------------------


'.source .haskell':


  'Pragma':
    prefix: '{-#'
    body: '{-# $1 #-'

  'Module':
    prefix: 'module'
    body:
      """
      module ${1:Name}
          (
          ) where
      """

  'Definition':
    prefix: '='
    body: '${1:name} ${2:pattern} = ${0:definition}'

  'Function':
    prefix: 'fun'
    body: '''
      ${1:name} :: ${2:Type}
      ${1} ${3:pattern} = ${4:definition}
      '''

  '#!/usr/bin/env…':
    prefix: '#!'
    body: '#!/usr/bin/env ${1:runhaskell}'

  'Lambda Expression':
    prefix: '\\'
    body: "\\\\${1:pattern} -> ${0:expression}"

  'Left Arrow':
    prefix: '<'
    body: '${1:name} <- ${0:expression}'

  'Main':
    prefix: 'main'
    body: '''
      module Main where

      main :: IO ()
      main = ${0:putStrLn "Hello World"}
      '''

  'Right Arrow':
    prefix: '>'
    body: '${1:expression} -> ${0:expression}'

  'case … of …':
    prefix: 'case'
    body: '''
      case ${1:expression} of
      \t${2:pattern} -> ${3:expression}
      \t${4:otherwise} -> ${5:expression}
      '''

  'class …':
    prefix: 'cla'
    body: '''
      class ${1:Class} where
      \t${0:definition}
      '''

  'data …':
    prefix: 'dat'
    body: 'data ${1:Type} = ${0:Other}'

  'do …':
    prefix: 'do'
    body: '''
      do
      \t${1:return ${0:expression}}
      '''

  'if … then … else …':
    prefix: 'if'
    body: '''
      if ${1:condition}
      \tthen ${2:expression}
      \telse ${3:expression}
      '''

  'import … hiding …':
    prefix: 'imph'
    body: 'import ${1:Module} hiding (${2:function})'

  'import …':
    prefix: 'imp'
    body: 'import ${1:Module}'

  'import qualified …':
    prefix: 'impq'
    body: 'import qualified ${1:Module}${2: as ${3:Mod}}'

  'instance …':
    prefix: 'ins'
    body: '''
      instance ${1:Class} ${2:Type} where
      \t${0:definition}
      '''

  'let …':
    prefix: 'let'
    body: '''
      let
      \t${1:name} = ${2:expression}
      \tin ${0:expression}
      '''

  'newtype …':
    prefix: 'new'
    body: 'newtype ${1:Type} = ${0:Other}'

  'type …':
    prefix: 'typ'
    body: 'type ${1:Type} = ${0:Other}'

  'where …':
    prefix: 'where'
    body: '''
      where
      \t${0:definitions}
      '''

  'INLINE':
    prefix: 'INL'
    body: '{-# INLINE ${1:function} #-}'

  'NOINLINE':
    prefix: 'NOINL'
    body: '{-# NOINLINE ${1:function} #-}'

  'INLINABLE':
    prefix: 'INLINABLE'
    body: '{-# INLINABLE ${1:function} #-}'

  'LANGUAGE':
    prefix: 'LANG'
    body: '{-# LANGUAGE ${1:ext} #-}'

  'UNPACK':
    prefix: 'UNPACK'
    body: '{-# UNPACK #-} '

  'OPTIONS_GHC':
    prefix: 'GHC'
    body: '{-# OPTIONS_GHC -${1:option} #-}'

  #----------------------------------------------------------------------------------------------------------------------------
  ###### UNICODE ######
  #----------------------------------------------------------------------------------------------------------------------------

  'Proportion':
    prefix: '::'
    body: '∷' #0x2237

  'Rightwards double arrow':
    prefix: '=>'
    body: '⇒'

  'For all':
    prefix: 'forall'
    body: '∀' #0x2200

  'Rightwards arrow':
    prefix: '->'
    body: '→' #  0x2192

  'Leftwards arrow':
    prefix: '<-'
    body: '←' #0x2190

  'Leftwards arrow-tail':
    prefix: '-<'
    body: '↢' #0x2919

  'Rightwards arrow-tail':
    prefix: '>-'
    body: '↣' #0x291A

  'Leftwards double arrow-tail':
    prefix: '-<<'
    body: '⤛' # 0x291B

  'Rightwards double arrow-tail':
    prefix: '>>-'
    body: '⤜' # 0x291C

  'Black star':
    prefix: '*'
    body: '★' #0x2605
'.source .haskell:not(.comment)':

  'Guard':
    prefix: '|'
    body: '| ${1:predicate} = ${0:definition}'
'.source .haskell.comment':

  'Haddock Postfix':
    prefix: '|'
    body: '| ${0:documentation}'

  'Haddock Prefix':
    prefix: '^'
    body: '^ ${0:documentation}'
'.source .haskell.constant.language.empty-list':

  'List Comprehension':
    prefix: '['
    body: '[ ${1:expression} | ${2:${3:name} <- ${4:expression}}$0'
'.source .haskell.meta.type':

  'deriving …':
    prefix: 'der'
    body: 'deriving (${0:Class})'
'.source.cabal':

  'executable':
    prefix: 'exe'
    body: '''
      executable ${1:exename}
        hs-source-dirs:      ${2:app}
        main-is:             ${3:Main.hs}
        ghc-options:         -Wall -threaded -rtsopts -with-rtsopts=-N
        build-depends:       base
                           , ${4:libname}
        default-language:    Haskell2010
       '''

  'library':
    prefix: 'lib'
    body: '''
      library
        hs-source-dirs:      ${1:src}
        exposed-modules:     ${2:Lib}
        other-modules:       ${3:Module}
        build-depends:       base >= 4 && < 5
        ghc-options:         -Wall
        default-language:    Haskell2010
      '''

  'repository':
    prefix: 'repo'
    body: '''
      source-repository head
        type:     git
        location: https://github.com/${1:githubuser}/${2:project}
      '''

  'test':
    prefix: 'test'
    body: '''
      test-suite ${1:test-name}
        type:                exitcode-stdio-1.0
        hs-source-dirs:      ${2:test}
        main-is:             ${3:Spec.hs}
        build-depends:       base
                           , ${4:libname}
        ghc-options:         -Wall -threaded -rtsopts -with-rtsopts=-N
        default-language:    Haskell2010
      '''


#------------------------------------------------------------------------------------------------------------------------------
#
# 8888888b.  888     888  .d8888b. 88888888888
# 888   Y88b 888     888 d88P  Y88b    888
# 888    888 888     888 Y88b.         888
# 888   d88P 888     888  "Y888b.      888
# 8888888P"  888     888     "Y88b.    888
# 888 T88b   888     888       "888    888
# 888  T88b  Y88b. .d88P Y88b  d88P    888
# 888   T88b  "Y88888P"   "Y8888P"     888
#
#------------------------------------------------------------------------------------------------------------------------------


'.source.rust':


  'allow':
    prefix: 'allow'
    body: '#[allow(${1:lint})]'

  'allow!':
    prefix: 'allow!'
    body: '#![allow(${1:lint})]'

  'deny':
    prefix: 'deny'
    body: '#[deny(${1:lint})]'

  'deny!':
    prefix: 'deny!'
    body: '#![deny(${1:lint})]'

  'derive':
    prefix: 'derive'
    body: '#[derive(${1:Trait})]'

  'enum':
    prefix: 'enum'
    body: '''
    enum ${1:TypeName} {
    \t$2
    }
    '''

  'fn':
    prefix: 'fn'
    body: '''
    fn ${1:function_name}($2) {
    \t${3:unimplemented!()}
    }
    '''

  'fnr':
    prefix: 'fnr'
    body: '''
    fn ${1:function_name}($2) -> ${3:TypeName} {
    \t${4:unimplemented!()}
    }
    '''

  'for':
    prefix: 'for'
    body: '''
    for ${1:variable} in ${2:iterator} {
    \t$3
    }
    '''

  'if':
    prefix: 'if'
    body: '''
    if ${1:expression} {
    \t$2
    }
    '''

  'impl':
    prefix: 'impl'
    body: '''
    impl ${1:TypeName} {
    \t$2
    }
    '''

  'let':
    prefix: 'let'
    body: 'let ${1:variable} = ${2:value};'

  'loop':
    prefix: 'loop'
    body: '''
    loop {
    \t//
    \t$1
    }
    '''

  'macro':
    prefix: 'macro'
    body: '''
    macro_rules! ${1:macro_name} {
    \t($2) => ($3);
    }
    '''

  'main':
    prefix: 'main'
    body: '''
    fn main() {
    \t${1:unimplemented!()}
    }
    '''

  'match':
    prefix: 'match'
    body: '''
    match ${1:expression} {
    \t$2
    }
    '''

  'print':
    prefix: 'print'
    body: 'print!("${1:{${2::?}\\}}", ${3});'

  'println':
    prefix: 'println'
    body: 'println!("${1:{${2::?}\\}}", ${3});'

  'static':
    prefix: 'static'
    body: 'static ${1:CONSTANT}: ${2:TypeName} = ${3:value};'

  'struct':
    prefix: 'struct'
    body: '''
    struct ${1:TypeName} {
    \t$2
    }
    '''

  'test':
    prefix: 'test'
    body: '''
    #[test]
    fn ${1:test_name}() {
    \t${2:unimplemented!()}
    }
    '''

  'testmod':
    prefix: 'testmod'
    body: '''
    #[cfg(test)]
    mod tests {
    \tuse super::*;\n\n
    \t#[test]
    \tfn ${1:test_name}() {
    \t\t${2:unimplemented!()}
    \t\t}
    \t}
    \t'''

  'trait':
    prefix: 'trait'
    body: '''
    trait ${1:TypeName} {
    \t$2
    }
    '''

  'type':
    prefix: 'type'
    body: 'type ${1:TypeName} = ${2:TypeName};'

  'warn':
    prefix: 'warn'
    body: '#[warn(${1:lint})]'

  'warn!':
    prefix: 'warn!'
    body: '#![warn(${1:lint})]'

  'while':
    prefix: 'while'
    body: '''
    while ${1:expression} {
    \t$2
    }
    '''


#------------------------------------------------------------------------------------------------------------------------------
#
# 8888888b.
# 888   Y88b
# 888    888
# 888   d88P
# 8888888P"
# 888 T88b
# 888  T88b
# 888   T88b
#
#------------------------------------------------------------------------------------------------------------------------------


'.source.r':


# 888b    888                            8888888888                         888    d8b
# 8888b   888                            888                                888    Y8P
# 88888b  888                            888                                888
# 888Y88b 888  8888b.  88888b.   .d88b.  8888888 888  888 88888b.   .d8888b 888888 888  .d88b.  88888b.  .d8888b
# 888 Y88b888     "88b 888 "88b d88""88b 888     888  888 888 "88b d88P"    888    888 d88""88b 888 "88b 88K
# 888  Y88888 .d888888 888  888 888  888 888     888  888 888  888 888      888    888 888  888 888  888 "Y8888b.
# 888   Y8888 888  888 888  888 Y88..88P 888     Y88b 888 888  888 Y88b.    Y88b.  888 Y88..88P 888  888      X88
# 888    Y888 "Y888888 888  888  "Y88P"  888      "Y88888 888  888  "Y8888P  "Y888 888  "Y88P"  888  888  88888P'
#
#------------------------------------------------------------------------------------------------------------------------------


  'slid_win {}':
    prefix: 'slid_win(f_seq = , f_bin_size = )'
    body: 'slid_win(${1:f_seq}, ${2:f_bin_size})'


#        d8888      888                                                  888
#       d88888      888                                                  888
#      d88P888      888                                                  888
#     d88P 888  .d88888 888  888  8888b.  88888b.   .d8888b .d88b.   .d88888
#    d88P  888 d88" 888 888  888     "88b 888 "88b d88P"   d8P  Y8b d88" 888
#   d88P   888 888  888 Y88  88P .d888888 888  888 888     88888888 888  888
#  d8888888888 Y88b 888  Y8bd8P  888  888 888  888 Y88b.   Y8b.     Y88b 888
# d88P     888  "Y88888   Y88P   "Y888888 888  888  "Y8888P "Y8888   "Y88888
#
#------------------------------------------------------------------------------------------------------------------------------


  'ggplotting':
    prefix: 'ggplot'
    body: """{
    \tggplot(
    \t\tdata = $1,
    \t\taes(
    \t\t\t$2
    \t\t)
    \t) +
    \t$3
    }
    """

  'convert to tibble {tibble}':
    prefix: 'as_tibble'
    body: 'tibble::as_tibble(${1:?})'

  'tibble {tibble}':
    prefix: 'tibble()'
    body: 'tibble::tibble($1)'

  'filter {dplyr}':
    prefix: 'filter()'
    body: 'dplyr::filter($1)'

  'read_delim {readr}':
    prefix: 'read_delim'
    body: """readr::read_delim(
    \tfile = $1,
    \tdelim = $2,
    \tcol_names = $3
    )"""

  'slice {dplyr}':
    prefix: 'slice(.data, ...)'
    body: 'dplyr::slice($1)'

  'select {dplyr}':
    prefix: 'select(.data, ...)'
    body: 'dplyr::select($1)'

  'pull {dplyr}':
    prefix: 'pull(.data, ...)'
    body: 'dplyr::pull($1)'

  'mutate {dplyr}':
    prefix: 'mutate(.data, ...)'
    body: 'dplyr::mutate($1)'

  'add_column {tibble}':
    prefix: 'add_column(.data, ..., .before = NULL, .after = NULL)'
    body: 'tibble::add_column($1)'


# 888888b.
# 888  "88b
# 888  .88P
# 8888888K.   8888b.  .d8888b  888  .d8888b
# 888  "Y88b     "88b 88K      888 d88P"
# 888    888 .d888888 "Y8888b. 888 888
# 888   d88P 888  888      X88 888 Y88b.
# 8888888P"  "Y888888  88888P' 888  "Y8888P
#
#------------------------------------------------------------------------------------------------------------------------------


  'iteration through list':
    prefix: 'for ls'
    body: """for ( $1 in seq_along($2) ) {
    \t#
    \twhich_$3 <- names($2)[$1]
    \t$4
    }"""

  'iteration through vector':
    prefix: 'for vc'
    body: """for ( $1 in seq_along($2) ) {
    \t#
    \twhich_$3 <- $2[$1]
    \t$4
    }"""

  'iteration through matrix or data.frame':
    prefix: 'for df'
    body: """for ( $1 in 1:dim($2)[$3] ) {
    \t#
    \twhich_$4 <- $2[$1]
    \t$5
    }"""

  'writetable {utils}':
    prefix: 'writetable(x)'
    body: """write.table(
    \t$1,
    \tfile = "$2",
    \tsep = "$3",
    \tappend = ${4:FALSE},
    \tcol.names = ${5:TRUE},
    \trow.names = FALSE,
    \tquote = FALSE
    )"""

  'seq_along {base}':
    prefix: 'seq_along()'
    body: 'seq_along($1)'

  'paste0 {base}':
    prefix: 'paste0()'
    body: 'paste0($1)'

  'save {base}':
    prefix: 'save(..., file = ".RData") '
    body: 'save(${1:...}, file = "$2.RData")'

  'tryCatch {base}':
    prefix: 'tryCatch(expr, ..., finally)'
    body: """tryCatch(
    \texpr = {
    \t\t$1
    \t},
    \terror = function(f_err){
    \t\t$2
    \t},
    \twarning = function(f_warn){
    \t\t$3
    \t},
    \tfinally = {
    \t\t$4
    \t}
    )"""


#------------------------------------------------------------------------------------------------------------------------------


  'apply function over marigin {base}':
    prefix: 'apply(x, MARGIN, FUN)'
    body: 'apply(${1:x}, ${2:MARGIN}, ${3:FUN})'

  'apply function over a List or vector {base}':
    prefix: 'lapply(x, FUN)'
    body: 'lapply(${1:x}, ${2:FUN})'

  'apply function over a ragged array {base}':
    prefix: 'tapply(x, FUN)'
    body: 'tapply(${1:x}, ${2:FUN})'

  'combine values {base}':
    prefix: 'c(x)'
    body: 'c(${1:})'

  'convert to array {base}':
    prefix: 'as.array'
    body: 'as.array(${1:?})'

  'convert to data frame {base}':
    prefix: 'as.data.frame(x)'
    body: 'as.data.frame(${1:x})'

  'convert to numeric {base}':
    prefix: 'as.numeric(x)'
    body: 'as.numeric(${1:x})'

  'convert to logical {base}':
    prefix: 'as.logical(x)'
    body: 'as.logical(${1:?})'

  'convert to complex {base}':
    prefix: 'as.complex(x)'
    body: 'as.complex(${1:x})'

  'convert to character {base}':
    prefix: 'as.character(x)'
    body: 'as.character(${1:x})'

  'attach data {base}':
    prefix: 'attach'
    body: 'attach(${1:data})'

  'breaks out loop {base}':
    prefix: 'break'
    body: 'break'

  'round to smallest integer {base}':
    prefix: 'ceiling(x)'
    body: 'ceiling(x)'

  'computes the combinations  {base}':
    prefix: 'choose(n,k)'
    body: 'choose(${1:n},${2:k})'

  'correlation {base}':
    prefix: 'cor()'
    body: 'cor(${1:x})'

  'combine by columns {base}':
    prefix:'cbind()'
    body:'cbind(${0:},${1:})'

  'create data frames  {base}':
    prefix: 'data.frame(x)'
    body: 'data.frame($1)'

  'detach {base}':
    prefix: 'detach'
    body: 'detach(${1:data})'

  'lagged of vector {base}':
    prefix: 'diff(x)'
    body: 'diff(${1:x})'

  'dimension {base}':
    prefix: 'dim(x)'
    body: 'dim(${1:x})'

  'show files {base}':
    prefix: 'dir'
    body: 'dir()'

  'empirical cumu. dist. fun. {base}':
    prefix: 'ecdf(x)'
    body: 'ecdf(${1:x})'

  'FALSE {base}':
    prefix: 'FALSE'
    body: 'FALSE'

  'round to largest integer {base}':
    prefix: 'floor(x)'
    body: 'floor(${1:x})'

  'for Loop {base}':
    prefix: 'for'
    body: """
    \tfor ( ${1:i} in ${2::} ) {
    \t\t#
    \t\t$3
    \t}
    \t"""

  'function {base}':
    prefix: 'function'
    body: """
    $1 <- function(

    \t${2:# ARGUMENTS}
    ) {
    \t${0:# BODY}
    \t${3:return($4)}
    }
    \t"""

  'display plot of object {Idisplay}':
    prefix: 'display'
    body: """
    \tdisplay(${1:x})
    """

  'getwd get workDir {base}':
    prefix:'getwd'
    body:'getwd()'

  'help via dispaly {IRdispaly}':
    prefix: 'help(display(x))'
    body: 'help(display(${1:x}))'

  'help via {base}':
    prefix: 'help()'
    body: 'help(${1:?})'

  'hist {base}':
    prefix: 'histogram'
    body:'hist(${1:x},freq=FALSE)'


  'intersetion of sets {base}':
    prefix: 'intersect(x, y)'
    body: 'intersect(${1:x},)'


  'if,else if,else {base}':
    prefix: 'ifelseifelse'
    body: """
    if ( ${1:true} ) {
    \t#
    \t$2
    } else ( ${3:false} ) {
    \t#
    \t$4
    } else {
    \t#
    \t$5
    }
    """

  'if,else {base}':
    prefix: 'ifelse'
    body: """
    if ( ${1:true} ) {
    \t#
    \t$2
    } else {
    \t#
    \t$3
    }
    """

  'ifelse {base}':
    prefix: 'ifelse(,,)'
    body: """
    ifelse (${1:true},$2,$3)
    """

  'if [monoline] {base}':
    prefix: 'if1'
    body: 'if ( ${1:true} ) $2'

  'if [multiline] {base}':
    prefix: 'if0'
    body: """
    if ( ${1:true} ){
    \t#
    \t$2
    }
    """

  'test for mising {base}':
    prefix: 'is.na(x)'
    body: 'is.na(${1:?})'

  'test for null {base}':
    prefix: 'is.null(x)'
    body: 'is.null(${1:x})'

  'test for array {base}':
    prefix: 'is.array(x)'
    body: 'is.array(${1:x})'

  'test for data frame {base}':
    prefix: 'is.data.frame(x)'
    body: 'is.data.frame(${1:?})'

  'test for numeric {base}':
    prefix: 'is.numeric(x)'
    body: 'is.numeric(${1:x})'

  'test for complex {base}':
    prefix: 'is.complex(x)'
    body: 'is.complex(${1:x})'

  'test for character {base}':
    prefix: 'is.character(x)'
    body: 'is.character(${1:x})'

  'NULL {base}':
    prefix: 'NULL'
    body: 'NULL'

  'Kolmogorov-Smirnov test {stat}':
    prefix: 'ks.test(x, y)'
    body: 'ks.test(${1:x},)'

  'library {base}':
    prefix: "library()"
    body: """
    \tlibrary(${1:})
    \t"""

  'length {base}':
    prefix: 'length(x)'
    body: 'length(${1:x})'

  'mean with trim {base}':
    prefix: 'mean(x, trim=0,na.rm=FALSE)'
    body: 'mean(${1:x},trim=0,na.rm=FALSE)'

  'mean {base}':
    prefix: 'mean(x)'
    body: 'mean(${1:x})'

  'mit NA {stat}':
    prefix: 'na.omit()'
    body: 'na.omit(${0:x})'

  'number of columns {base}':
    prefix: 'ncol(x)'
    body: 'ncol(${1:x})'

  'number of rows {base}':
    prefix: 'nrow(x)'
    body: 'nrow(${1:x})'

  'option to resize plot {base}':
    prefix: 'options(repr.plot.width=4, repr.plot.height=3)'
    body: 'options(repr.plot.width=4, repr.plot.height=3)'

  'sample quantile {stats}':
    prefix: 'quantile(x, probs=)'
    body: 'quantile(${1:x},probs=)'

  'calculayte range {base}':
    prefix: 'range(x)'
    body: 'range(${1:x})'

  'return ranks of values {base}':
    prefix: 'rank(x)'
    body: 'rank(${1:x})'

  'combine by row {base}':
    prefix:'rbind()'
    body:'rbind(${1}, ${2:})'

  'read csv {utils}':
    prefix: 'read.csv(x, file=".csv")'
    body: 'read.csv(${0:x}, file=".csv", sep="", header=TRUE, row.names=TRUE, col.names=TRUE)'

  'read table {utils}':
    prefix: 'read.table(x, file=".csv")'
    body: 'read.table(${0:x}, file=".csv", sep="", header=TRUE, row.names=TRUE, col.names=TRUE)'

  'read delim {utils}':
    prefix: 'read.delim(x, file = ".csv")'
    body: 'read.delim(${1:x}, file = ".csv", sep = "", header = TRUE, row.names = TRUE, col.names = TRUE)'

  'remove all everything {base}':
    prefix:'rm(list = ls())'
    body:  'rm(list = ls())'

  'remove objects {base}':
    prefix:'rm(x)'
    body:  'rm(${0:x})'

  'round {base}':
    prefix: 'round(x, digits = 0)'
    body: 'round(${0:x}, digits = 0)'

  'Read R Code from a File {base}':
    prefix:'source(file = "")'
    body: 'source(file = $1)'

  'sort a vector or factor {base}':
    prefix:'sort(x, decreasing = FALSE)'
    body: 'sort(${0:x},decreasing = FALSE)'

  'sample1 {base}':
    prefix: 'sample(x, size, replace = FALSE, prob = NULL)'
    body: 'sample(${1:x}, ${2:size}, replace = FALSE, prob = NULL)'

  'sample2 {base}':
    prefix: 'sample(x, n)'
    body: 'sample(${1:x}, ${2:?})'

  'difference of sets {base}':
    prefix: 'setdiff(x, y)'
    body: 'setdiff(${1:x},)'

  'sequence  {base}':
    prefix: 'sequence (from,to,by)'
    body: 'seq(${1:from},${2:to},${3:by})'

  'set working dirc {base}':
    prefix:'setwd("")'
    body:'setwd("")'

  'compare two sets {base}':
    prefix: 'setequal(x, y)'
    body: 'setequal(${1:x},)'

  'rounded as significant value {base}':
    prefix: 'signif(x, digits=0)'
    body: 'signif(x, digits=0)'

  'sort {base}':
    prefix: 'sort(x)'
    body: 'sort(${1:x})'

  'return system time {base}':
    prefix: 'Sys.time()'
    body: 'Sys.time()'

  'summary {base}':
    prefix:'summary(x)'
    body:'summary(${0:x})'

  't.test {stats}':
    prefix:'t.test(x, alternative ="two.sided",mu=0)'
    body:'t.test(${0:x},alternative ="two.sided",mu=)'

  't.test with details {stats}':
    prefix:'t.test(x, y=NULL,.....)'
    body:'t.test(${0:x},y=NULL,alternative =c("two.sided","less","greater"),mu=?,paired=FALSE,var.equal=FALSE,conf.level=0.95 )'

  'return without duplicate {base}':
    prefix: 'unique(x)'
    body: 'unique(${1:x})'

  'scaling and cetering {base}':
    prefix: 'scale(x)'
    body: 'scale(${1:x})'

  'build a contingency table {base}':
    prefix: 'table(x, y)'
    body: 'table(${1:x},)'

  'TRUE {base}':
    prefix: 'TRUE'
    body: 'TRUE'

  'union of sets {base}':
    prefix: 'union(x, y)'
    body: 'union(${1:x},)'

  'variance {stats}':
    prefix: 'var(x)'
    body: 'var(${1:x})'

  'while Loop {base}':
    prefix: 'while'
    body: """
    \twhile (${1:?}){
    \t}
    \t"""

  'write {base}':
    prefix: 'write(x, file="data")'
    body: 'write(${1:x},file="")'

  'write.csv {base}':
    prefix: 'write.csv(x, file=".csv")'
    body: 'write.csv(${1:x},file=".csv",row.names=TRUE,col.names=TRUE)'

  'write.table {base}':
    prefix: 'write.table(x, file=".csv")'
    body: 'write.table(${1:x},file=".csv",row.names=TRUE,col.names=TRUE)'

  'log {base}':
    prefix: 'log(x)'
    body: 'log(${1:x})'

  'log with base {base}':
    prefix: 'logb(x, base=exp(1))'
    body: 'logb(${1:x},base=exp(1))'

  'log10 {base}':
    prefix: 'log10(x)'
    body: 'log10(${1:x})'

  'exponential {base}':
    prefix: 'exp(x)'
    body: 'exp(${1:x})'

  'cos {base}':
    prefix: 'cos(x)'
    body: 'cos(${1:x})'

  'sin {base}':
    prefix: 'sin(x)'
    body: 'sin(${1:x})'

  'tan {base}':
    prefix: 'tan(x)'
    body: 'tan(${1:x})'

  'arc-cos {base}':
    prefix: 'acos(x)'
    body: 'acos(${1:x})'

  'arc-sin {base}':
    prefix: 'asin(x)'
    body: 'asin(${1:x})'

  'arc-tan {base}':
    prefix: 'atan(x)'
    body: 'atan(${1:x})'

  'hyperbolic  cos{base}':
    prefix: 'cosh(x)'
    body: 'cosh(${1:x})'

  'hyperbolic  sin{base}':
    prefix: 'sinh(x)'
    body: 'sinh(${1:x})'

  'hyperbolic  tan{base}':
    prefix: 'tanh(x)'
    body: 'tanh(${1:x})'

  'arc cosh {base}':
    prefix: 'acosh(x)'
    body: 'acosh(${1:x})'

  'arc-sinh {base}':
    prefix: 'asinh(x)'
    body: 'asinh(${1:x})'

  'arc-tanh {base}':
    prefix: 'atanh(x)'
    body: 'atanh(${1:x})'


#------------------------------------------------------------------------------------------------------------------------------
#
#  .d8888b.   .d8888b.        d8888 888             d8888
# d88P  Y88b d88P  Y88b      d88888 888            d88888
# Y88b.      888    888     d88P888 888           d88P888
#  "Y888b.   888           d88P 888 888          d88P 888
#     "Y88b. 888          d88P  888 888         d88P  888
#       "888 888    888  d88P   888 888        d88P   888
# Y88b  d88P Y88b  d88P d8888888888 888       d8888888888
#  "Y8888P"   "Y8888P" d88P     888 88888888 d88P     888
#
#------------------------------------------------------------------------------------------------------------------------------


'.source.scala':


  'case class scaffolding':
    prefix: 'ccc'
    body: 'class ${1:Class}(${2/(\\S+\\s*:)/val $1/g}) {\n  override def hashCode = 0 ${2/(\\S+)\\s*:[^,]+(,?)/+ $1.##/g}\n  override def equals(other: Any) = $1.unapply(this) == $1.unapply(other)\n  override def canEqual(other: Any) = other.isInstanceOf[$1]\n}\n\nobject $1 {\n  def apply(${2:arguments}): $1 = new $1(${2/(\\S+)\\s*:[^,]+/$1/g})\n  def unapply(other: Any) = other match {\n    case x: $1 => import x._ ; Some(${2/(\\S+)\\s*:[^,]+/$1/g})\n    case _     => None\n  }\n}\n'

  'case class':
    prefix: 'case class'
    body: 'case class $1${2:($3)} ${4:extends ${5:Any} }${6:{\n  $7\n\\}}$0'

  'case':
    prefix: 'case'
    body: 'case ${1:_} => ${0}'

  'class':
    prefix: 'class'
    body: 'class $1${2:($3)} ${4:extends ${5:Any} }{\n\t$0\n}'

  'enumeration':
    prefix: 'enumeration'
    body: 'object ${1:MyEnumeration} extends Enumeration {\n  type $1 = Value\n  val ${2:${3:MyEnumeration1}, ${4:MyEnumeration2}} = Value\n}\n\n${5:import $1._}\n${0}'

  'for - Block':
    prefix: 'for'
    body: 'for ($1 <- ${2:${3:0} to ${4:10}}) {\n\t$0\n}'

  'for - Yield':
    prefix: 'for'
    body: 'for {\n  $1 <- ${2:${3:0} to ${4:10}}\n} yield $0'

  'if':
    prefix: 'if'
    body: 'if ($1) {\n\t$2\n}\n'

  'import mutable/immutable':
    prefix: 'impc'
    body: 'import scala.collection.{ mutable, immutable, generic }'

  'lambda':
    prefix: 'lam'
    body: '($1) => ${2:{${3:}\\}}'

  'left arrow':
    prefix: '<-'
    body: '${1:"${2}"} <- ${3:"${4}"}'

  'main':
    prefix: 'main'
    body: 'def main(args: Array[String]): Unit = {\n  $1\n}\n'

  'match':
    prefix: 'match'
    body: 'match {\n\tcase ${1:_} => $0\n}\n'

  'method':
    prefix: 'def'
    body: 'def ${1:method}${2:(${4:arg}: ${5:Type})} = {\n\t${0}\n}'

  'object with main method':
    prefix: 'omain'
    body: 'object $1 {\n  def main(args: Array[String]): Unit = {\n    $2\n  }\n}\n'

  'object':
    prefix: 'object'
    body: 'object $1 ${2:extends ${3:Any} }{\n\t$0\n}'

  'println':
    prefix: 'pl'
    body: 'println($0)'

  'right arrow':
    prefix: '->'
    body: '${1:"${2}"} -> ${3:"${4}"}'

  'script header':
    prefix: 'script'
    body: '#!/bin/sh\n  exec scala "\\$0" "\\$@"\n!#\n\n$1'

  'shortcut - case class':
    prefix: 'cc'
    body: 'case class'

  'shortcut - class':
    prefix: 'c'
    body: 'class'

  'shortcut - enumeration':
    prefix: 'enum'
    body: 'enumeration'

  'shortcut - match':
    prefix: 'm'
    body: 'match'

  'shortcut - object':
    prefix: 'obj'
    body: 'object'

  'shortcut - trait':
    prefix: 't'
    body: 'trait'

  'toString':
    prefix: 'tostr'
    body: 'override def toString(): String =  $0 \n'

  'trait':
    prefix: 'trait'
    body: 'trait $1 {\n\t$0\n}'

  'try/catch':
    prefix: 'try'
    body: 'try { \n  ${1:// ...}\n} catch {\n  case e: Exception => $0\n}'

  'with':
    prefix: 'with'
    body: 'with ${1:Any}'

  'scaladoc':
    prefix: '/**'
    body: '/**\n * $0\n */'


#------------------------------------------------------------------------------------------------------------------------------
#
# 8888888888 888b    888 8888888b.
# 888        8888b   888 888  "Y88b
# 888        88888b  888 888    888
# 8888888    888Y88b 888 888    888
# 888        888 Y88b888 888    888
# 888        888  Y88888 888    888
# 888        888   Y8888 888  .d88P
# 8888888888 888    Y888 8888888P"
#
#------------------------------------------------------------------------------------------------------------------------------
